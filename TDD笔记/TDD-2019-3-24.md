2019/3/24 周日

## 测试驱动开发(TDD)-笔记一

​	TDD是以测试作为开发过程的中心，在编写任何产品代码之前，首先编写用于定义产品代码行为的测试，而编写的产品代码又要以使测试通过为目标。

##### 	要求：测试可以完全自动化地运行，在对代码重构前后必须运行测试。

### TDD目标

​	代码整洁可用（clean code that works）

### TDD开发所经历的阶段

​	(1)不可运行--写一个不能工作的测试程序，一开始这个测试程序甚至不能编译。

​	(2)可运行--尽快让这个测试程序工作，为此可以在程序中使用一些不合情理的方法。

​	(3)重构--消除在让测试程序工作的过程中产生的重复设计，优化设计结构。

### TDD过程

​	(1)快速增加一个测试

​	(2)运行所有测试，发现最新的测试不通过

​	(3)做一些小小的改动

​	(4)运行所有测试，全部通过

​	(5)重构代码，消除重复设计，优化设计结构

### 计划清单(to-do list)

​	将工作任务细分，划入清单

​	**任务1** 完成后 ~~**任务1**~~

### 资金实例

当瑞士法郎与美元的兑换率为2:1的时候，5美元+10瑞士法郎=10美元  

> #### 	Task
>
> 1. **5美元 * 2 = 10 美元**  
> 2. **将"amount"定义为私有**  
> 3. **Dollar类有副作用吗？**
> 4. **钱数必须为整数？**
>

乘法如下：

```java
@Test 
public void testMultiplication(){
  Dollar five = new Dollar(5);
  five.times(2);
  assertEquals(five.amount,10);
}
```

​	测试不通过，缺少Dollar类、缺少构造函数、times(int)方法、没有amount域，一一加上

**Dollar**

```java
public class Dollar{
  int amount;
  Dollar(int amount){  
  }
  void times(int multiplier){
  }
}
```

​	继续测试，失败。 amount未初始化

**Dollar**

`int amount = 10;`

测试通过

#### 依赖关系与重复性设计

> ​	测试程序与代码所存在的问题不在于重复设计，而在于代码与测试程序之间的依赖关系—--你不可能只改动其中一个而不改动另外一个。
>
> ​	如果问题出在依赖关系上，那么其表现就是重复性设计。重复性设计通常表现为逻辑上的重复设计——相同的表达式在代码的多个地方出现。利用各种对象可以很好地抽象出逻辑上的重复设计。

这里重复性设计出现在测试中的数据与代码的数据之间

**Dollar**

`int amount = 5 * 2;`

一步无法消除5和2，可以不在对象初始化时给amount赋值，通过times方法赋值

**Dollar**

```java
int amount;
Dollar(int amount){
	this.amount = amount;
}

void times(int multiplier){
	amount *=  multiplier;
}
```



> ​	Task
>
> 1. **~~5美元 * 2 = 10 美元~~**  
> 2. **将"amount"定义为私有**  
> 3. **Dollar类有副作用吗？**
> 4. **钱数必须为整数？**

假设在Dollar对象上施加一个操作，Dollar对象改变，测试连续乘，代码如下：

```java
@Test public void testMultiplication(){
 Dollar five = new Dollar(5);
 five.times(2);
 assertEquals(five.amount,10);
 five.times(3);
 assertEquals(five.amount,15);
}
```

当第一次调用times()后，five变为10，第二个断言测试失败。

新增一个product中间对象

```java
@Test public void testMultiplication(){
  Dollar five = new Dollar(5);
  Dollar product = five.times(2);
  assertEquals(10,product.amount);
  product = five.times(3);
  assertEquals(15,product.mount);
}
```

改变Dollar.times()函数的声明,返回一个新的带有正确amount值得Dollar 对象

Dollar

```java
Dollar times(int multiplier){
	return new Dollar(amount * multiplier);
}
```



> ​	Task
>
> 1. **~~5美元 * 2 = 10 美元~~**  
> 2. **将"amount"定义为私有**  
> 3. ~~**Dollar类有副作用吗？**~~
> 4. **钱数必须为整数？**
> 5. **实现equals()函数**
> 6. **实现hashCode()函数**

测试相等性，首先5美元等于5美元

```java
public void testEquality(){
  assertTrue(new Dollar(5).equals(new Dollar(5)));
}
```

测试没有运行通过。equals()的伪实现直接返回true:

Dollar

```java
public boolean equals(Object object){

​	return true;

}
```

接下来采用三角法，5美元！= 6美元

```java
@Test public void testEquality(){

​	assertTrue(new Dollar(5).equals(new Dollar(5)));

​	assertFalse(new Dollar(5).equals(new Dollar(6)));

}
```

现在使判等函数equals()一般化：

Dollar

```java
public voidequals(Object object){

​	Dollar dollar = (Dollar)object;

​	return amount == dollar.amount;

}

```

由于判等问题已解决，可以直接在Dollar对象之间作比较，所以amount可以设为私有

Dollar

`private int amount;`

> ​	Task
>
> 1. **~~5美元 * 2 = 10 美元~~**  
> 2. ~~**将"amount"定义为私有**~~  
> 3. ~~**Dollar类有副作用吗？**~~
> 4. **钱数必须为整数？**
> 5. **~~实现equals()函数~~**
> 6. **实现hashCode()函数**
> 7. **与空对象判等**
> 8. **与非同类对象判等**
> 9. **5瑞士法郎 * 2 = 10 瑞士法郎**

从概念上讲Dollar.times()操作应该返回一个Dollar对象，这个对象的值是原对象的值乘以乘数，所以重写第一第二个断言，让Dollar对象之间进行比较，由于中间对象product作用不大，可采用内联方式：

```java
@Test public void testMultiplication(){

​	Dollar five = new Dollar(5);

​	assertEquals(new Dollar(10),five.times(2));

​	assertEquals(new Dollar(15),five.times(3));

}
```

接下来写一个类似Dollar的对象，法郎。测试和代码类似Dollar：

```java
@Test public void testFrancMultiplication(){

​	Franc five = new Franc(5);

​	assertEquals(new Franc(10),five.times(2));

​	assertEquals(new Franc(15),five.times(3));

}
```

Franc

```java
public class Franc{

​	private int amount;

​	public Franc(int mount){

​		this.amount = amount;

​	}
​	Franc times(int multiplier){

​		return new Franc(amount * multiplier);

​	}

​	public boolean equals(Object object){

​		Franc franc = (Franc) object;

​		return amount == franc.amount;

​	}

}
```



> ​	Task
>
> 1. **~~5美元 * 2 = 10 美元~~**  
> 2. ~~**将"amount"定义为私有**~~  
> 3. ~~**Dollar类有副作用吗？**~~
> 4. **钱数必须为整数？**
> 5. **~~实现equals()函数~~**
> 6. **实现hashCode()函数**
> 7. **与空对象判等**
> 8. **与非同类对象判等**
> 9. **~~5瑞士法郎 * 2 = 10 瑞士法郎~~**
> 10. **美元Dollar/瑞士法郎Franc之间的重复设计**
> 11. **普通判等**
> 12. **普通相乘**

由于Dollar对象和Franc对象存在大量的重复性设计，可以利用抽象的方式，让他们继承同一个父类，将共同变量，方法上移至父类Money中：

Money

```java
class Money{

​	protected int amount;//amount的可见性必须由private改为protected，以便子类能看见

}
```

将Dollar和Franc的equals方法进行修改，并上移至父类Money中：

Dollar

```java
public boolean equals(Object object){

​	Money money = (Money)object;

​	return amount == money.amount;

}
```

法郎的判等测试：

```java
@Test public void testEquality(){

​	assertTrue(new Dollar(5).equals(new Dollar(5)));

​	assertFalse(new Dollar(5).equals(new Dollar(6)));
  
​	assertTrue(new Franc(5).equals(new Franc(5)));

​	assertFalse(new Franc(5).equals(new Franc(6)));
  
​	assertFalse(new Franc(5).equals(new Dollar(5)));//测试5美元==5法郎？？？

}
```

通过比较两个Money对象相等当且仅当他们的数值和类均相同：

Money

```java
public boolean equals(Object object){

​	Money money = (Money) object;

​	return amount == money.amount && getClass().equals(money.getClass());

}
```



> ​	Task
>
> 1. **~~5美元 * 2 = 10 美元~~**  
> 2. ~~**将"amount"定义为私有**~~  
> 3. ~~**Dollar类有副作用吗？**~~
> 4. **钱数必须为整数？**
> 5. **~~实现equals()函数~~**
> 6. **实现hashCode()函数**
> 7. **与空对象判等**
> 8. **与非同类对象判等**
> 9. **~~5瑞士法郎 * 2 = 10 瑞士法郎~~**
> 10. **美元Dollar/瑞士法郎Franc之间的重复设计**
> 11. **~~普通判等~~**
> 12. **普通相乘**
> 13. **~~比较法郎对象与美元对象~~**
> 14. **货币？**

接下来去除共同的times()函数，以实现多币种计算。

